PPT（1）：在学习spring的过程中，我自己实践了一个小型的spring，主要实现了IOC依赖注入，一些基本bean配置的支持。在边实践边学习spring源码实现的过程，我总结了一些感兴趣的知识点，主要是下面三个方面：容器初始化bean的流程，容器是怎么解决bean的依赖注入问题的，还有关于容器支持多线程的一些探讨。我将从这三个方面进行spring的学习报告：

PPT（2）：首先要明确一个概念，spring是怎么认识我在xml中配置的bean的？spring在实际操作中只读取一个数据结构，叫beanDefinition，它保存了一个bean的所有配置信息，比如这个bean的ID是什么，作用域是什么。我们在xml中配置的每一个bean信息，都会通过相应的解析映射操作，最终转换为spring操作可识别的beanDefininion，然后这些beanDefinition被注册到一个map中，被spring统一管理。

PPT（3）：容器在初始化过程中，就是遍历BeanDefinition，读取其中的配置数据，然后判断bean配置是否为单例非延迟加载。这里有必要解释一下单例的概念，spring的单例是在当前容器只会被创建一次，并保存在spring单例池中，由spring容器来管理，以后每次getBean操作都是从单例池中获取的。这种单例bean一般在容器初始化过程中就被创建好了，常用于对bean的状态无关的场景，比如辅助工具类、DAO组件、业务逻辑组件等等。
我们刚刚说到容器判断bean配置是否为单例非延迟，如果是的话，它就会再去单例池判断这个bean是否加载好了，因为spring保证每个单例bean只被创建一次。如果单例池没有这个bean，spring就开始了bean的加载工作。在这里我只关注了bean的setter注入方式，在这种方式下，容器会先构造bean对象，然后将这个bean对象需要配置的属性通过setter方法注入进去，关于具体我会在之后探讨。当这个bean完成了构造和属性注入后，这个bean就算创建完成了，最后就将这个bean注册到单例池中，以后我需要用到这个bean就不需要再创建了，直接从这个单例池中获取就行。单例池的实现是一个map结构，只需要通过bean的name就能获取到对应的bean。
这儿还有两个问题，第一个是为什么要设置延迟加载单例，而不在初始化时全部加载完，因为有些单例bean可能存在很复杂的依赖关系，为了初始化这个单例bean需要创建很多相关的对象，可能会在初始化的时候产生很大的性能开销。而这样的bean在之后的业务处理中甚至可能不一定会用到，因此这种bean适合需要的时候在创建。
但是设置了延迟初始化的bean，是有可能在初始化阶段就加载好了，比如另一个需要在初始化加载的bean，它的创建过程依赖某个延迟初始化bean，那么延迟初始化bean就会提前在初始化阶段加载。但是这种设计违背了延迟初始化的初衷，这不是很好的做法。


PPT（4）：这是运行时getBean的流程，主要用于创建延迟初始化的bean和原型bean，它的流程和之前容器初始化时创建bean差不多，其实都是调用同一个函数getbean实现的。单例和原型创建的主要的区别是，在构造原型bean的过程中，spring不会对原型对象进行缓存操作，每次获取原型对象都会重新进行整个构造和属性注入的流程，也就是说每次获取的原型bean都是不同的。这也带来一个问题，如果这个原型bean的依赖关系比较复杂，并且多次执行get这个bean对象的操作，将会在程序运行期产生较大开销。
同时，在实际代码编写中，要尽量提前实例化bean，这样的话bean配置中的任何错误就能立即被发现。如果bean在程序运行中才首次实例化，那很有可能出现日常业务很难进入该bean实例化的分支的情景，导致bean配置错误很难被发现；并且运行期发生在业务操作中的bean实例化出现配置错误，很可能会对实际业务产生影响。


PPT（5）：说完了bean的大致创建流程，再来说一下bean的依赖注入，很多情况下，一个bean的创建需要完成对自身属性的配置，而自身属性可能是基本类型常量、或者容器，或者其他bean的引用，这里我们主要关注其他bean的引用。像这张图，A依赖B和C的引用，B依赖D和E的引用，C依赖F的引用，那么在创建A的过程中，就必须拥有B、C、D、E、F的对象，如果单例池中有，那最好，如果没有，就要一层一层嵌套的去创建相应对象，并完成相应对象的属性的注入。这种依赖注入主要有两种方式实现，一种是构造器注入，即通过带有参数的构造函数注入属性，先创建参数bean，后创建实际bean；还有一种是setter注入方式，先构造实际bean，再创建属性bean，最后通过set方法将参数bean注入到实际bean中。在后面报告中，如果没有特殊说明的话，我所说的依赖注入即是通过set方法完成注入的。
这是一个具体的注入过程动画，白色是指完成了构造，但尚未完成属性注入的bean，黄色是指构造完成的bean。先构造A，然后判断待注入的属性引用B是否存在，如果不存在的话构造B，然后再判断B的属性引用D是否存在，如果不存在继续构造D，这时D是没有引用依赖的，因此D创建完成，然后将D注入B，然后B再去寻找自己的另一个属性引用E是否存在...整个过程是通过深度遍历的形式，嵌套调用getBean方法，寻找“无引用依赖或者已经完成依赖注入的叶子bean对象”的过程，然后一级一级完成依赖bean的创建，最后完成A的创建。这种方式保证了注入A的所有属性、及属性的引用都已经被完全创建完毕，A是一个创建完整的对象。


PPT（6,7）：刚刚说到了依赖注入，我们现在再来看一下特殊的注入情况，循环注入问题。即A依赖于对象B，而B又依赖于对象A。这种情况下类似于一个鸡蛋问题，要想先有蛋，必须先有鸡，但是没有蛋，就不可能存在鸡。如果我们不做任何处理，在具体的实现中，很可能出现下面两种情况：第一种是构造器方式的循环注入，因为要想完成A的构造工作，必须拥有一个创建完成的B的对象，但是这时B连个对象都没有；而这时开始构造B，又需要一个创建完成的A对象，而这时A也连构造都无法进行，何谈对象。因此通过构造器方式构成的循环依赖，是无法解决的，因为每个bean的构造器执行都缺少相应对象，而缺少的对象又无法构造，因此要不然陷入死循环，要不然只能抛出异常。
然后是setter方式的循环注入，如图可以看到，容器先完成了对象A的构造，然后期望给它注入对象B，因为不存在B对象，因此容器接着构造了B对象，这时B对象需要注入一个创建完成的A，之前我们创建的A只完成了构造工作，并未创建完成，因此B没有找到这个A，因此B就继续请求构造A，这个时候程序就进入了一个死循环。这时虽然陷入了死循环，但是情况比构造器方式要好，因为这里容器至少做了一点事，就是把A和B的对象都构造出来了，只是他们对于注入的要求都比较高，只愿意注入创建完成的对象，谁都不愿意先降低身段进行注入，导致注入循环无法完成。这时只要暴露出构造完成的一个bean对象，然后让另一个对象降低注入要求，先临时完成构造对象的注入，这时循环就能被打破，从而解决循环注入问题。

PPT（8）：在具体的spring实现中，容器维护单例注入池和原型注入池两个结构，单例注入池以map形式实现，保存构造完成但未完成属性注入的单例对象，原型注入池以set形式实现，保存构造完成但未完成属性注入的原型对象的名字。因为spring承诺不会对原型对象进行缓存，所以原型注入池只有对象名字，不保存完成构造的对象。
我们先从单例出发，每一个待注入的对象都保存在单例待注入池中，一旦该对象完成注入，便从待注入池中移出，具体的注入流程我将会在下一节描述。这时容器只需检测待注入池会不会插入已经存在的对象，一旦出现重复的对象，那么肯定是这个对象出现循环依赖了，就应该及时抛出异常。但是只完成检查是不够的，spring可以设置是否允许单例存在循环依赖。如果设置允许的话，那么spring检测到B需要注入属性A，而A虽然没有创建完成，但至少在待注入池中已经完成了构造，就不会再去请求创建A的操作了，而是临时将这个只完成构造的A的对象注入到B中，完成B的注入，打破循环，从而完成整个循环注入过程。
但是这种方案存在风险，我们把尚未完成注入的A注入到B中，B并不知道自己的属性是尚未完成注入的，这时B以为自己完成了所有的注入工作，调用自己的init方法，并将自己放入单例池中，此时如果对B中的A属性进行操作，很有可能因为A尚未完成注入而出现问题。但是这种问题是循环注入这种设计本身就会导致的问题，spring并不能完全解决，因此我们在日常设计中需要尽可能的避免出现循环引用的设计。
如果是原型对象，因为spring承诺不会维护原型对象的缓存，因此原型待注入池中只维护构造完成但未完成属性注入的对象的名字，因为没有维护已经构造的对象，原型对象不支持解决循环依赖问题。

PPT（9）：这是一个具体的循环注入的解决流程。主要是若待注入池存在对应bean，则将待注入池的bean注入实际对象，不再进行新的bean的构造。同时要注意，已经创建完成的bean应该及时从待注入池中移出，如果这儿E为原型对象，在E1处完成创建后没有将对象名称从原型注入池移出，则在E2处，容器检测到原型注入池已经存在E的对象名称，将认为此时出现了循环依赖而抛出异常。

PPT（10）：说完了注入问题，我们再来探讨一下多线程问题，多线程问题和注入问题是存在很紧密的联系的。首先我们继续探讨待注入池的概念，有两个线程分别在进行bean创建的工作。线程1刚完成对象B的创建，此时待注入池存在A和E；就在这时线程2的C对象需要注入属性E，在构造E的过程中发现待注入池中已经存在了E了，这时容器就会错误的认为出现了循环引用，从而抛出异常。但实际上并不存在循环引用。因此待注入池应该是线程相关的，如果被多个线程共用将产生错误。在spring实现中，通过threadlocal机制实现了每个线程均有一个属于自己的待注入池，因此也就解决了待注入池共享可能带来的错误问题。

PPT（11,12）：原型对象的加载过程主要涉及原型待注入池，单例对象加载还需要涉及单例池的操作。一般的单例对象都在容器初始化的过程中就被创建好了，容器初始化过程是单线程的。但是依旧存在这样的场景，一个bean被设置为了单例延迟加载，并且单例池之前并没有创建这个bean，这是两个线程同时检查到这个bean并未被创建，然后同时开启了对这个bean的创建操作。这样的话就会创建2个同类的单例，这是spring不允许的。spring的处理机制是在整个单例对象的创建过程中加同步锁。每次只能让一个线程获得这个同步锁，然后判断单例池中是否存在该bean，如果不存在则开始创建过程。
这种设计能够保证每次只有一个线程执行创建单例和写入单例池操作，但是锁的范围非常大，将读单例池也锁上了。一个线程在进行创建beanA的操作，并且操作过程没有占用单例容器，这时另一个线程进行读取单例池中已经存在的beanB的操作也会被阻塞。理论上读取单例池中某个已经存在的bean只需获得单例池的容器锁，它并不需要关系其他线程正处于创建bean的哪个过程，只要不是正获得单例池容器锁执行写入单例操作就行。我从循环引用中寻找到了一个答案，如果一个线程如图正在执行bean创建过程，此时出现了循环引用，B完成了属性注入，并被写入到了单例池，但是此时对象B的属性A注入并不完整，如果这时没有锁住读单例池操作，另一个线程很有可能会读取不完整的对象B，并进行操作，这时可能就会出现问题。按照spring的实现，在创建bean的过程中将单例池的读写操作全部锁住后，就能避免读取到未完全注入的B对象的问题。
当然，这种实现并不是一定的，我认为可以再维护一个新的容器，在注入过程中新创建的单例bean单独放在新容器中维护，直到此次创建操作全部结束后，再将新容器的bean导入到单例池中，也能解决多线程读取到未完全注入的对象的问题。

